<!--Generated by a crappy script that Craig Andera wrote : https://github.com/candera/cs-atom--><feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"><id>feed-id</id><updated>2011-12-25T08:45:05.87-05:00</updated><title type="text">Blog Title Here</title><generator version="7.00" uri="http://www.blogger.com">Blogger</generator><entry><id>52958</id><published>2008-09-11T10:41:00.0-05:00</published><updated>2008-09-11T10:41:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Hello and Thanks</title><content type="html">&lt;p&gt;So, 11 years after starting at another training company (and helping to establish the UK office); two years after leaving the other company as a full time employee; about 5 years after the guys created Pluralsight; I'm finally here! So hello, and thanks to the Pluralsight guys for having me!&lt;/p&gt;</content><author><name>kevin-jones</name></author><thr:total>1</thr:total></entry><entry><id>52960</id><published>2008-09-11T12:04:20.0-05:00</published><updated>2008-09-11T12:04:20.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Hello and Thanks</title><content type="html">Best of luck in the new gig, Kev!
</content><author><name>Anonymous</name></author><thr:in-reply-to ref="52958"></thr:in-reply-to></entry><entry><id>53614</id><published>2008-09-22T12:03:00.0-05:00</published><updated>2008-09-22T12:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Learning Rails - Part 1</title><content type="html">&lt;p&gt;I've been looking at Ruby and Rails for a long time, when I say looking at here what I really mean is staring through the glass and wondering what the fuss was about. Now that I finally have a MacBook I decided to actually sit down and learn Rails and Ruby at the same time. This means that on my hour long commute to and from my current contract I'm writing web code, and much fun it is. The commute is split over two trains so each part is about 30 minutes which gives me a very fractured learning experience but I'm still getting something done.&lt;/p&gt;
&lt;p&gt;I wanted to use the web app I'm working on (it's only a toy) as a learning tool. This means that a) I wanted to minimize the new concepts and b) not be led by the hand too much. Because of that I decided that I would initially not use &lt;a href="http://api.rubyonrails.org/classes/ActionController/Resources.html"&gt;REST based routing&lt;/a&gt; as I would need to understand more about REST and using the built in routing would hide the routing system from me. So taking my routes in hand I initially did things the 'hard' way (actually, it's not that hard)&lt;/p&gt;
&lt;p&gt;I finally figured that I knew enough to then try the RESTian approach, so firing up my trusty console, and TextMate I tried adding a new controller and model to the application.&lt;/p&gt;
&lt;p&gt;I ran a command, something like,&lt;/p&gt;
&lt;pre&gt;script/generate scaffold foo&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;then ran
&lt;/p&gt;
&lt;pre&gt;rake db:migrate&lt;/pre&gt;
&lt;p&gt;pointed the browser at http://localhost:3000/foos and everything seemed good. I added a new foo, life was good. Then I tried to browse to http://localhost:3000/foo/1 and I get an error:
&lt;/p&gt;
&lt;pre&gt;Unknown action
No action responded to 1
&lt;/pre&gt;
&lt;p&gt;After much Googling and running of&lt;/p&gt;
&lt;pre&gt;rake routes&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;I couldn't find an answer.
&lt;/p&gt;
&lt;p&gt;Eventually after much re-reading of the routing chapter in &lt;b&gt;&lt;a href="http://pragprog.com/titles/rails2/agile-web-development-with-rails"&gt;The Book&lt;/a&gt;&lt;/b&gt; something must have lodged in my head and I decided to kill the web server and restart it, and suddenly the routes started working. The moral is "you do sometimes need to re-start the rails web server"!&lt;/p&gt;
&lt;p&gt;The second issue was even more stupid. After fix the above problem, and getting my head more around the REST idea I decided I needed a bunch of controllers, so I duly run&lt;/p&gt;
&lt;pre&gt;script/generate scaffold bars&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;restart the server and immediately get strange errors along the lines of
&lt;/p&gt;
&lt;pre&gt;undefined method `edit_bars_result_path' for #&amp;lt;ActionView::Base:0x255a508&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;eh!
&lt;/p&gt;
&lt;p&gt;Rails experts will be laughing right now, or thinking 'been there, done that.' Rails adopts naming conventions, in this case models and controllers are singular. RESTian routing is based around the ideas of things and collections of things, the things are singular and the collections are plural. I tried to generated things that were already plural (bars), and the RAILs pluralization had no idea what to do with it, so the naming broke (at least that's what I think happened :) )&lt;/p&gt;
&lt;div class="posttagsblock"&gt;&lt;a rel="tag" href="http://technorati.com/tag/Rails"&gt;Rails&lt;/a&gt;, &lt;a rel="tag" href="http://technorati.com/tag/Ruby"&gt;Ruby&lt;/a&gt;&lt;/div&gt;</content><author><name>kevin-jones</name></author></entry><entry><id>53645</id><published>2008-09-25T01:32:22.0-05:00</published><updated>2008-09-25T01:32:22.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Learning Rails - Part 2</title><content type="html">&lt;p&gt;I wanted to make this a series about Rails and about Ruby. To that end I'm going to write a series of entries on building an MVC application. As I said in the previous post I am a Ruby and Rails neophyte, so I'll be learning as I go along, regard this as a developer's journal. The aim being that you can learn from the mistakes that I make. If this really gets going I also hope to do some screencasts along the way.&lt;/p&gt;
&lt;p&gt;What am I going to write - a blog of course (is there any other sort of web app out there today :) ). I chose blogging software because&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Everybody understands what a blog is, so no trying to figure out the behaviour&lt;/li&gt;

  &lt;li&gt;It gives me a chance to play with different formats (html and RSS)&lt;/li&gt;

  &lt;li&gt;At some point I'll need to write support for the various APIs (atom, etc)&lt;/li&gt;

  &lt;li&gt;There'll be chances to use AJAX&lt;/li&gt;

  &lt;li&gt;I can learn how to deploy to Apache&lt;/li&gt;

  &lt;li&gt;It shouldn't take too long to get things going&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm going to rely heavily on the &lt;a href="http://pragprog.com/titles/rails2/agile-web-development-with-rails"&gt;'Agile Development With Rails'&lt;/a&gt; book, and hopefully any feedback I get. I'm learning Ruby at the same time as Rails and Ruby is a very idiomatic language, I know I'll get some of the idioms wrong, so again feedback is welcome. Oh and initially I'm doing this on MacBook using TextMate as the editor. At some point I'm going to play with NetBeans and Eclipse as tools and so try out JRuby, not that I like a challenge of learning 17 new things at once!&lt;/p&gt;
&lt;h3&gt;Start at the beginning. Go on the end and then stop, said the Red Queen&lt;/h3&gt;
&lt;p&gt;So the beginning of a Rails app is the code generator, to create the application I fire up a terminal make sure I'm in the right directory and call&lt;/p&gt;
&lt;pre&gt;
rails rblog
&lt;/pre&gt;
&lt;p&gt;This gives the well known directory structure of&lt;/p&gt;
&lt;pre&gt;
app
config
db
doc
lib
log
public
script
test
tmp
vendor
&lt;/pre&gt;
&lt;p&gt;Most of the time I'll be in the app directory (that's where the models, controllers and views are), but I'll also use stuff from the db directory where the 'migrations' are stored, in the public directory where public the web files are and in config, where various setup files live.&lt;/p&gt;
&lt;p&gt;Once the application has been created I can fire up another terminal (I usually have three open, one for my commands, one for the server and another to see the log file), change the the project directory and run the server with the command 'script/server'&lt;/p&gt;
&lt;p&gt;This starts the server on port 3000, the server I'm using here is Mongrel, you can also start WEBrick. There's plenty of discussion on these servers out on the web so I won't go into the differences here.&lt;/p&gt;
&lt;p&gt;Once the server is running you can point your browser at http://localhost:3000 and you should see something like:&lt;/p&gt;
&lt;p&gt;&lt;img alt="RailsHomePage" height="346" width="480" src="http://www.pluralsight.com/community/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/kevinj/RailsHomePage.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;I'm going to use &lt;a href="http://mysql.com"&gt;MySql&lt;/a&gt; for the database and this needs to be configured. To do this I've edited config/database.yml to look like this:&lt;/p&gt;
&lt;pre&gt;
development:
adapter: mysql
encoding: utf8
database: rblog_development
username: root
password:
socket: /tmp/mysql.sock
&lt;/pre&gt;
&lt;p&gt;Adding similar entries for test and production databases. Once that's done I created the development database&lt;/p&gt;
&lt;pre&gt;
mysqladmin -u root create rblog_development
&lt;/pre&gt;
&lt;p&gt;Now that all the necessary structure is in place I can create the first controllers and models. What do I know about the blog? I know it's going to have users, users can have blogs and blogs will have entries and comments. There may be more things eventually, such as tags, categories, pingbacks etc, but for now that's enough. So not to get too far ahead of myself I decided to create scaffolding for users, blogs and blogentries.&lt;/p&gt;
&lt;p&gt;For the users model I'm going to user a similar approach to that used in the Rails book, so the user will have an email address and password, the password will be stored as a hash will be salted. A user will have a name that can be displayed on comments or on a blog and users may also own blogs. For now I'm going to limit this to one blog per user, but in the future this may expand to multiple blogs.&lt;/p&gt;
&lt;p&gt;Running&lt;/p&gt;
&lt;pre&gt;
script/generate scaffold user email:string hashed_password:string name:string blog_id:integer
&lt;/pre&gt;
&lt;p&gt;gives me what I want. Doing something similar for blogs and blogentries&lt;/p&gt;
&lt;pre&gt;
script/generate scaffold blog title:string sub_title:string owner_id:integer admin:boolean
script/generate scaffold blog_entry title:string entry:text author_id:integer entry_added:datetime entry_last_edited:datetime
&lt;/pre&gt;
&lt;p&gt;creates those models and their corresponding controllers and migrations.&lt;/p&gt;
&lt;p&gt;Notice that as in my previous post I'm using singular names for the model components, so user, blog and blog_entry.&lt;/p&gt;
&lt;p&gt;Now that's done it's then onto setting out some of the UI and writing some unit testing code.&lt;/p&gt;

&lt;div class="posttagsblock"&gt;&lt;a rel="tag" href="http://technorati.com/tag/Rails"&gt;Rails&lt;/a&gt;, &lt;a rel="tag" href="http://technorati.com/tag/Ruby"&gt;Ruby&lt;/a&gt;&lt;/div&gt;</content><author><name>kevin-jones</name></author></entry><entry><id>53689</id><published>2008-09-29T05:33:22.0-05:00</published><updated>2008-09-29T05:33:22.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Rails - Testing</title><content type="html">&lt;p&gt;Now that we have a Rails app up and running, all be it a simple one, it's time to think about testing. When you generate an application you also get a test structure created for us. This structure lets us create unit, functional and integration tests. Each kind of test has a different scope and I'll start, as we should, with unit tests.&lt;/p&gt;
&lt;p&gt;
Looking in the test/unit directory there's a single ruby source file for each model created previously, each of these files looks like this
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
class BlogEntryTest &amp;lt; ActiveSupport::TestCase
  # Replace this with your real tests.
  def test_truth
    assert true
  end
end
&lt;/pre&gt;
&lt;p&gt;
Pretty straightforward, assert that true is true. (If this is your first glance at Ruby code the first line says that BlogEntryTest derives from TestCase and the 'def' statement defines a method).
&lt;/p&gt;
&lt;p&gt; 
Before running the test I create the test database
&lt;/p&gt;
&lt;pre&gt;
mysqladmin -u root create rblog_test
&lt;/pre&gt;
&lt;p&gt;
There are two ways (at least) to run this test, running
&lt;/p&gt;
&lt;pre&gt;
ruby -I test test/unit/blog_entry_test.rb 
&lt;/pre&gt;
&lt;p&gt;
(-I test here includes the test directory in the search path)
or
&lt;/p&gt;
&lt;pre&gt;
rake test:units
&lt;/pre&gt;
&lt;p&gt;
Running the first command line on my machine gives this:
&lt;/p&gt;
&lt;pre&gt;
Loaded suite test/unit/blog_entry_test
Started
E
Finished in 0.033476 seconds.

  1) Error:
test_truth(BlogEntryTest):
ActiveRecord::StatementInvalid: Mysql::Error: Table 'rblog_test.users' doesn't exist: DELETE FROM `users`
&lt;/pre&gt;
&lt;p&gt;
This shows us that the database tables don't exist. Running
&lt;/p&gt;
&lt;pre&gt;
rake db:test:prepare
&lt;/pre&gt;
&lt;p&gt;
fixes this and re-running the test now succeeds.
&lt;/p&gt;
&lt;pre&gt;
Started
.
Finished in 0.095619 seconds.
&lt;/pre&gt;
&lt;p&gt;
It's also possible to run
&lt;/p&gt;
&lt;pre&gt;
rake test:units
&lt;/pre&gt;
&lt;p&gt;
This will run all the unit tests
&lt;/p&gt;
&lt;pre&gt;
Started
...
Finished in 0.056533 seconds.

3 tests, 3 assertions, 0 failures, 0 errors
&lt;/pre&gt;
&lt;p&gt;
Now that there's some confidence that the testing framework is in place it's time to start thinking about real tests.
&lt;/p&gt;
&lt;p&gt;
The user class represents a user of the system, either a user with a blog or a user posting comments. This user must have a username, email and password. The user class looks like this
&lt;/p&gt;
&lt;pre name="code" class="ruby"&gt;
class User &amp;lt; ActiveRecord::Base
  validates_presence_of :name
  validates_presence_of :email
  validates_uniqueness_of :email
  validates_confirmation_of :password
  validate :password_non_blank
&lt;/pre&gt;
&lt;p&gt;
This suggest some tests. Does the user have a name and email, is the emil unique and does the password have some data! The first test checks that the user is valid
&lt;/p&gt;
&lt;pre name="code" class="ruby"&gt;
class UserTest &amp;lt; ActiveSupport::TestCase
  def test_empty_user_is_invalid
    user = User.new
    assert !user.valid?
    assert !user.errors.empty?
    assert user.errors.invalid?(:name)
    assert user.errors.invalid?(:email)
    assert_equal "Missing password", user.errors.on_base
  end
&lt;/pre&gt;
&lt;p&gt;
The test creates a User then calls the valid? method (if you're new to Ruby the ? on the end of a method is part of the method name and indicates that the method returns a boolean, a ! on the end indicates that the method mutates data) . The test asserts that the user is not valid and then asserts that the appropriate errors have been added to the errors collection.
&lt;/p&gt;
&lt;p&gt;
The code has other tests for the user, checking that the password and password_confirmation match and that the password is not blank. There is also a test that a User is valid if all the fields are set correctly, none of these are shown here but the code is available &lt;a href="http://www.mantiso.com/svn/rblog/trunk"&gt;here&lt;/a&gt; not that there's much to see at the moment!
&lt;/p&gt;
&lt;p&gt;
The final test for the moment checks that the User must have a unique email. The code looks like this:
&lt;/p&gt;
&lt;pre name="code" class="ruby"&gt;
def test_user_unique_email
  user = User.new(:name =&amp;gt; "Test Name",
                  :email =&amp;gt; users(:kevin).email,
                  :password =&amp;gt; "wibble",
                  :password_confirmation =&amp;gt; "wibble")

  assert !user.save
  assert_equal "has already been taken", user.errors.on(:email)
  assert_equal ActiveRecord::Errors.default_error_messages[:taken], user.errors.on(:email)      
end
&lt;/pre&gt;
&lt;p&gt;
The thing of interest in this code is the line
&lt;/p&gt;
&lt;pre name="code" class="ruby"&gt;
:email =&amp;gt; users(:kevin).email,
&lt;/pre&gt;
&lt;p&gt;
This loads a fixture named :kevin. Fixtures are test data defined in a yml file (YAML Ain't a Markup Language) file. Fixtures have names and cen be loaded by name in the test code. The fixture looks like this:
&lt;/p&gt;
&lt;pre&gt;
kevin:
  email: kevin@test.com
  hashed_password: hash
  name: Kevin
&lt;/pre&gt;
&lt;p&gt;
The fixture data is loaded into the database, then the line 'users(:kevin).email' loads the fixture and gets its email value. This means that the test tries to save a user with the same email address as one that already exists, and that should fail.
&lt;/p&gt;









</content><author><name>kevin-jones</name></author></entry><entry><id>53850</id><published>2008-10-10T09:37:16.0-05:00</published><updated>2008-10-10T09:37:16.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Rails - Database Access</title><content type="html">&lt;p&gt;One of the driving forces of Rails is to make things easier for developers. It does this partly by taking decisions out of developers hands. It's an 'opinionated' framework, and one of the opinions it has is on the pattern to use for database access. Its choice in this case is the 'active record' pattern. 
&lt;/p&gt;
&lt;p&gt;
Rails has an &lt;span style="white-space: pre;font-family:monospace"&gt;ActiveRecord&lt;/span&gt; module and the model classes all derive from&lt;/p&gt;
&lt;pre class="ruby"&gt;
ActiveRecord::Base
&lt;/pre&gt;for example
&lt;pre class="ruby"&gt;
BlogEntry &amp;lt; ActiveRecord::Base
&lt;/pre&gt;
&lt;p&gt;
it is this module that provides the active record support for the framework.
&lt;/p&gt;
&lt;p&gt;Like much of the rest of Rails, ActiveRecord follows naming conventions. Here for example the BlogEntry class represents a row in the blog_entries table. How does this happen?&lt;/p&gt;
&lt;p&gt;Looking back to the &lt;a href="/community/blogs/kevinj/archive/2008/09/25/learning-rails-part-2.aspx"&gt;Learning Rails - Part 2&lt;/a&gt; post you will see that this script was run&lt;/p&gt;
&lt;pre&gt;
script/generate scaffold blog_entry ...
&lt;/pre&gt;
&lt;p&gt;This script created two files, the file with the model class BlogEntry definition and a "migration". The migrations are "scripts" that help create and mange the database definitions, essentially they are DDL for Rails.&lt;/p&gt;
&lt;p&gt;Migrations are used to both set up and tear down databases. The files contain class definitions that specify the steps to take when managing the database.&lt;/p&gt;
&lt;p&gt;Migrations are timestamped so that it is easy to apply migrations in the correct order and to rollback those migrations in reverse order if needs be. The migrations live in the db/migrate directory. Currently there are 4 migrations in there&lt;/p&gt;
&lt;pre&gt;
20080925064318_create_sessions.rb       
20080925065056_create_blogs.rb
20080925064319_create_users.rb          
20080925065210_create_blog_entries.rb
&lt;/pre&gt;
&lt;p&gt;The first is a fairly standard Rails migration that creates the session tables (run &lt;span style="white-space: pre;font-family:monospace;"&gt;rake db:sessions:create&lt;/span&gt; to create this), the others are specific to this application. Each migration has a date-time as part of the file name and it's this name that determines the order in which the migrations are run. The 20080925065210_create_blog_entries.rb looks like this&lt;/p&gt;
&lt;pre class="ruby"&gt;
class CreateBlogEntries &amp;lt; ActiveRecord::Migration
  def self.up
    create_table  :blog_entries do |t|
      t.string    :title,             :null =&amp;gt; false
      t.text      :entry,             :null =&amp;gt; false
      t.integer   :author_id,         :null =&amp;gt; false
      t.datetime  :entry_added_date
      t.datetime  :entry_last_edited
      t.timestamps
    end
  end

  def self.down
    drop_table :blog_entries
  end
end
&lt;/pre&gt;
&lt;p&gt;So it's a class that derives from &lt;span style="white-space: pre;font-family:monospace;"&gt;ActiveRecord::Migration&lt;/span&gt; and provides two class methods (static methods to C#/C++ folks), up and down (it's the "self" that indicates that these are class methods and not instance methods). You can run the migration from the command line by using the Rake command&lt;/p&gt;
&lt;pre&gt;
rake db:migrate
&lt;/pre&gt;
&lt;p&gt;This runs any migrations that have not yet been run. How does it know which migrations to run? Tthere is a database table that holds the information about the migrations that have been run.&lt;/p&gt;
&lt;pre style="background-color:white; color:black; border: solid thin grey"&gt;
$ mysql -u root
mysql&amp;gt; use rblog_development
mysql&amp;gt; show tables;
&lt;/pre&gt;
&lt;p&gt;shows something like&lt;/p&gt;
&lt;pre style="background-color:white; color:black; border: solid thin grey"&gt;
+-----------------------------+
| Tables_in_rblog_development |
+-----------------------------+
| blog_entries                |
| blogs                       |
| schema_migrations           |
| sessions                    |
| users                       |
+-----------------------------+
&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre style="background-color:white; color:black; border: solid thin  grey"&gt;
mysql&amp;gt; select * from schema_migrations;


+----------------+
| version        |
+----------------+
| 20080923152418 |
| 20080923152427 |
| 20080923152435 |
| 20080925064318 |
| 20080925064319 |
| 20080925065056 |
| 20080925065210 |
+----------------+
&lt;/pre&gt;
&lt;p&gt;on my machine as I type this. Notice that the last entry in the table matches the datetime portion of the name of the last migration file.&lt;/p&gt;
&lt;p&gt;When a migration is run (assuming it has not yet been added to the database), then the &lt;span style="white-space: pre;font-family:monospace;"&gt;self.up&lt;/span&gt;
 method is executed. This method creates or modifies database entries. In the case of the blog_entries migration it creates the table and adds the eight columns from these five entries.
&lt;/p&gt;&lt;pre&gt;
(title, entry, author_id, entry_added_date, entry_last_edited and timestamps
&lt;/pre&gt;
&lt;p&gt;mysql shows this&lt;/p&gt;
&lt;pre style="background-color:white; color:black; border: solid thin  grey"&gt;
mysql&amp;gt; show create table blog_entries;
+--------------+---------------------------------+
| Table        | Create Table                    |
+--------------+---------------------------------+
| blog_entries | CREATE TABLE `blog_entries` (
`id` int(11) NOT NULL auto_increment,
`title` varchar(255) NOT NULL,
`entry` text NOT NULL,
`author_id` int(11) NOT NULL,
`entry_added_date` datetime default NULL,
`entry_last_edited` datetime default NULL,
`created_at` datetime default NULL,
`updated_at` datetime default NULL,
PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1           |
+--------------+---------------------------------+
&lt;/pre&gt;
&lt;p&gt;
Notice that timestamps turns into two columns, and that an id column has been added as a primary key
&lt;/p&gt;
&lt;p&gt;
A migration can also be rolled back. Running rake db:migrate &lt;span style="white-space: pre;font-family:monospace;"&gt;rollback&lt;/span&gt; will rollback the last migration, or a specific version can be specified. For example 
&lt;span style="white-space: pre; font-family:monospace;"&gt;rake db:migrate VERSION=20080925065056&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
Running the migrations this way runs the migrations in reverse order up to the specified migration, on the way the &lt;span style="white-space: pre;font-family:monospace;"&gt;self.down&lt;/span&gt; mwthod of each migration is called. For the &lt;span style="white-space: pre;font-family:monospace;"&gt;blog_entries&lt;/span&gt; migration that would drop the table. The &lt;span style="white-space: pre;font-family:monospace;"&gt;down&lt;/span&gt; method should undo whatever the &lt;span style="white-space: pre;font-family:monospace;"&gt;up&lt;/span&gt; method did! 
&lt;/p&gt;
&lt;p&gt;
One of the interesting (and frustrating) things about Rails is the way the migrations and the models work together. Running the &lt;span style="white-space: pre;font-family:monospace;"&gt;script/generate scaffold blog_entry&lt;/span&gt; creates two files, the migration and the model. Looking in the model file there is ... nothing, just the class definition. The knowledge about the members of this class is in the migrations. This takes DRY (Do Not Repeat Yourself) to the limit but it can mean looking in several files (there maybe more than one migration per model) to find everything that the class uses. If the migrations get too "spread out", i.e. there are three or more migrations with modifications to one table then it is worth amalgamating those migrations into one file.
&lt;/p&gt;
&lt;div class="posttagsblock"&gt;&lt;a rel="tag" href="http://technorati.com/tag/Rails"&gt;Rails&lt;/a&gt;, &lt;a rel="tag" href="http://technorati.com/tag/Ruby"&gt;Ruby&lt;/a&gt;&lt;/div&gt;</content><author><name>kevin-jones</name></author><thr:total>1</thr:total></entry><entry><id>53854</id><published>2008-10-10T13:04:01.0-05:00</published><updated>2008-10-10T13:04:01.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Rails - Database Access</title><content type="html">My last team did a lot with Rails. Here are some things we found with ActiveRecord...

- It was easier for us to update a set of migrations in place than to keep adding new ones. This reflected our build process and worked great.

- This part actually doesn't end up feeling that DRY once you start adding sizes to the DB to control use of space but also constraints to the model to enforce size limits before you go to the DB.

- If you start adding DB-specific stuff in your migrations, e.g., index generation and FK constraints, you end up moving your DB definition around using schemas instead of migrations, and you use a structure.sql file instead of schema.rb (there's a config param telling the system which to generate when you use rake to dump your schema).

Tim-</content><author><name>Anonymous</name></author><thr:in-reply-to ref="53850"></thr:in-reply-to></entry><entry><id>54002</id><published>2008-10-22T01:07:43.0-05:00</published><updated>2008-10-22T01:07:43.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Rendering and Layouts</title><content type="html">&lt;p&gt;As this is the Pluralsight blog I'm assuming that most people reading this are .Net folk and that you will have at least a passing familiarity with ASP.Net, so occasionally I'll draw comparisons with Microsoft's framework. ASP.Net has had, since 2.0, the concept of Master pages. These are pages that provode the overall structure of parts of a web site. ASP.Net lets a page author design a template that contains content placeholders, this template is called a 'master page', individual pages can then specify that they want to use a specific master page and also specify which content replaces which placeholder within the page. Internally this turns out to be a fairly convoluted mechanism as the master page and the content page have to be woven together so that the right events get delivered to the right thing at the right time.&lt;/p&gt;
&lt;p&gt;Rails, as you would expect, has a similar mechanism which known as 'layouts'.&lt;/p&gt;
&lt;p&gt;In a Rails app, content is defined in a template. If you use the default generators of Rails 2.0 these templates are in the form of .erb files. A .erb file is essentially an HTML page with "turd-lets" of code embedded into it between &amp;lt;% %&amp;gt; and &amp;lt;%= %&amp;gt; symbols. This is just like other templating technologies such as ASP, ASP.Net, JSP or PHP&lt;/p&gt;
&lt;p&gt;Templates are part of the view (obviously) and a typical template renders content for an action. For example in the rblog application there is a &lt;span style="white-space: pre;font-family:monospace;"&gt;BlogsController&lt;/span&gt; class this has an index action with an associated index template. Of course none of this is mandatory, this is though the default behaviour if you use the scaffolding. The templates live in app/views and this index template lives in app/views/blogs/index.html.erb&lt;/p&gt;
&lt;p&gt;The template looks something like this:&lt;/p&gt;
&lt;pre name="code" class="ruby"&gt;
&amp;lt;h1&amp;gt;Latest Output&amp;lt;/h1&amp;gt;


&amp;lt;div id='blog-entries-main-body'&amp;gt;
	&amp;lt;div id='blog-entries'&amp;gt;
		&amp;lt;% for blog_entry in @blog_entries %&amp;gt;
			&amp;lt;div class='blog-entry-surround'&amp;gt;
			    &amp;lt;span class="blog-title"&amp;gt;&amp;lt;%=h blog_entry.title %&amp;gt;&amp;lt;/span&amp;gt;
			    &amp;lt;div&amp;gt;&amp;lt;%=h blog_entry.entry %&amp;gt;&amp;lt;/div&amp;gt;
			    &amp;lt;span class="blog-author"&amp;gt;&amp;lt;%=h blog_entry.author_id %&amp;gt;&amp;lt;/span&amp;gt;
  			&amp;lt;/div&amp;gt;
		&amp;lt;% end %&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
The template is a mixture of HTML and ruby. This Ruby code iterates over a collection of blog_entries (stored in @blog_entries) and for each one formats some output.
&lt;/p&gt;
&lt;p&gt;
The action that causes this particular view to be rendered looks like:
&lt;/p&gt;
&lt;pre name="ruby" class="code"&gt;
def index
    @blog_entries = BlogEntry.find(:all, :order =&amp;gt; 'updated_at DESC', :limit =&amp;gt; 10)
    @blogs = Blog.find(:all)

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&amp;gt; @blogs }
    end
  end

&lt;/pre&gt;
&lt;p&gt;
The first thing to note is that there are two member variables initialized, @blogs and @blog_entries. These are initialized in the controller and are also available in the view, that's where the view gets its @blog_entries reference from. 
&lt;/p&gt;
&lt;p&gt;
The other piece of interest is the &lt;span style="white-space: pre;font-family:monospace;"&gt;respond_to&lt;/span&gt; section. This says that if the format is html use the default rendering (the '#' is a comment, so the 'index.html.erb' on that line is there as an aide memoire), and if the format is XML then use the XML renderer.
&lt;/p&gt;
&lt;p&gt;
This means that when a request comes into /blogs then the index action of the blogs controller is executed, the @blogs and @blog_entries objects are created, control passes to the view and the output is rendered. However the output looks like this...
&lt;/p&gt;

&lt;img alt="200810170814.jpg" height="422" width="480" src="http://www.pluralsight.com/community/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/kevinj/200810170814.jpg" /&gt;

&lt;p&gt;
There is some extra stuff in here, for example there is styling and also things like a Register and Login button. This extra HTML comes from the layouts.
&lt;/p&gt;
&lt;p&gt;
The layouts live in the app/layouts directory and by default there is one layout per controller, this is generated as part of the scaffolding. This means that if nothing explicit is done a default layout will be used, however there are various other ways to specify the layout needed, as will be seen.
&lt;/p&gt;
&lt;p&gt;
The layout used for the blogs page looks like this
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
&amp;lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv="content-type" content="text/html;charset=UTF-8" /&amp;gt;
  &amp;lt;title&amp;gt;RBlog: &amp;lt;%= controller.action_name %&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;%= stylesheet_link_tag 'general' %&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class="header" id="header"&amp;gt;
	&amp;lt;div id="header-message"&amp;gt;
		Welcome to RBlog
	&amp;lt;/div&amp;gt;
	&amp;lt;div id="flash"&amp;gt;
		&amp;lt;p&amp;gt;&amp;lt;%= flash[:notice] %&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div id="logon"&amp;gt;
		&amp;lt;%= link_to "Register", :action =&amp;gt; "register", :controller =&amp;gt; "authenticate"  %&amp;gt; 
		&amp;lt;%= link_to "Login", :action =&amp;gt; "login", :controller =&amp;gt; "authenticate" %&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class="main" id="main"&amp;gt;
&amp;lt;%= yield  %&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class="sidebar" id="sidebar"&amp;gt;
	&amp;lt;div id="bloglist"&amp;gt;
		&amp;lt;div id="blogs-list-title"&amp;gt;Blogs&amp;lt;/div&amp;gt;
		&amp;lt;% for blog in @blogs %&amp;gt;
		    &amp;lt;div class="blog-title"&amp;gt;&amp;lt;%= link_to h(blog.title), blog %&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;% end %&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class="footer" id="footer"&amp;gt;
	
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;
&lt;p&gt;
The highlights are:
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The use of &amp;lt;%= controller.action_name %&amp;gt; to get the name of the action used to show this page&lt;/li&gt;
&lt;li&gt;&amp;lt;%= stylesheet_link_tag 'general' %&amp;gt; to load a stylesheet, more than one can be specified&lt;/li&gt;
&lt;li&gt;The use if 'flash' to display messages&lt;/li&gt;
&lt;li&gt;The use of link_to to display URLs&lt;/li&gt;
&lt;li&gt;Access to data members from the controller (for blog in @blogs)&lt;/li&gt;
&lt;li&gt;The call to yield&lt;/li&gt;
&lt;/ul&gt; 

&lt;p&gt;
It's the last one that's most interesting here. It's the call to yield that says 'take the default rendered output from the view and display it at this point in the page'. One thing to note here is that the view 'code' has already been executed at this point, i.e. the view template is rendered, that output is saved, then the layout is executed and the output from the template inserted into the layout. 
&lt;/p&gt;
&lt;p&gt;
This layout is called 'blogslisting.html.erb' so is not the default layout for the blogs controller, this means that the code has to explicitly specify this layout to use. Like many things in Rails there is a great deal of flexibility in doing this. 
&lt;/p&gt;
&lt;p&gt;
A global or default layout can be specified in app/controllers/application.rb , this contains the base class that all controllers derive from. A 'layout' declaration can be added In the class definition. 
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
class ApplicationController &amp;lt; ActionController::Base
  layout "general"
&lt;/pre&gt;
&lt;p&gt;
A layout can also be specified per controller
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
class BlogsController &amp;lt; ApplicationController

  layout "blogslisting"
&lt;/pre&gt;
&lt;p&gt;
And this can be further overwritten on a per action basis. So if a given controller wants different layouts for each action it can have code something like this:
&lt;/p&gt;
&lt;pre&gt;
  def show
    
    @blog = Blog.find(params[:id])

    respond_to do |format|
      format.html {render(:layout =&amp;gt; "layouts/blog" )}
      format.xml  { render :xml =&amp;gt; @blog }
    end
  end

&lt;/pre&gt;
&lt;p&gt;
Where the code in the format.html block says to render with the layout with the 'layouts/blogs' layout file.
&lt;/p&gt;
&lt;p&gt;This piece is already much longer than I though it would be so it's time to stop. There's more to be said about this, such as getting multiple content into the layout (multiple calls to yield), and sharing content with partial page templates. More on that soon.&lt;/p&gt;
</content><author><name>kevin-jones</name></author><thr:total>3</thr:total></entry><entry><id>76223</id><published>2010-04-25T01:14:32.0-05:00</published><updated>2010-04-25T01:14:32.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">spokesman review blogs</title><content type="html">The way that joint venture marketing works is pretty simple, because it involves two businesses that work together, hence the name joint venture, in order to increase both of their customer bases. Generally speaking, a smaller business will join with</content><author><name>Anonymous</name></author><thr:in-reply-to ref="54002"></thr:in-reply-to></entry><entry><id>76302</id><published>2010-04-30T17:44:05.0-05:00</published><updated>2010-04-30T17:44:05.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Graco Nautilus 3 In 1 Car Seat in Matrix</title><content type="html">Nice article I've appreciated reading it as well as I've added your article in my personal list of associated blogs look it over http://www.graconautilus3in1carseats.com/tag/graco-nautilus-3-in-1-car-seat-pink/</content><author><name>Anonymous</name></author><thr:in-reply-to ref="54002"></thr:in-reply-to></entry><entry><id>89370</id><published>2010-06-03T02:22:57.0-05:00</published><updated>2010-06-03T02:22:57.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">free blog hosting domain</title><content type="html">Michael Jackson\'s ex Debbie Rowe wins 27k judgment against Florida woman in defamation case/ a March 3rd, 2010 Debbie Rowe wins judgment in defamation caseLOS ANGELESâ€” A judge has granted Michael Jackson\'s ex- wife, Debbie Rowe, a 27,000 judgment against</content><author><name>Anonymous</name></author><thr:in-reply-to ref="54002"></thr:in-reply-to></entry><entry><id>54324</id><published>2008-11-10T01:39:02.0-05:00</published><updated>2008-11-10T01:39:02.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Rails - Routing</title><content type="html">&lt;p&gt;
It's been a while since my last post, that's a mixture of being at PDC and battling with Rails routing so that I understand it better and so that I can bend it to my will! I've finally got something working to my liking but it's taken a while.
&lt;/p&gt;
&lt;p&gt;
Routing is a huge part of Rails and, like most things in Rails, I'm not going to be able to do it full justice in this post.
&lt;/p&gt;
&lt;p&gt;Rails provides a flexible and convenient routing mechanism, which sounds like marketing speak but is true. If the application uses RESTful routes then much of the work is done for it, although only if you want to work exactly the way Rails expects, otherwise you have to understand the routing to get it to fit into your scheme.
&lt;/p&gt;
&lt;p&gt;
Routing information is stored in a file called routes.rb which is in the config directory. The route data 'draws' routes by mapping from resources to HTTP verbs/URLs and vice versa. This means that for a given HTTP verb (GET say) and a given URL ("/blog/foo") there is a map to a specific controller/action pair. 
&lt;/p&gt;
&lt;p&gt;When a controller is generated from a script an entry is automatically placed in /config/routes.rb. For a 'blogs' controller the entry would look like this:
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
map.resources :blogs
&lt;/pre&gt;
&lt;p&gt;
This entry sets up a bunch of routes for the "blogs" controller in this application. There are several ways to see these routes. The generated BlogsController class will have a set of commented methods that show which URLs will be directed to which methods (shown here but shortened for convenience)
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
  # GET /blogs
  # GET /blogs.xml
  def index

  # GET /blogs/1
  # GET /blogs/1.xml
  def show

  # GET /blogs/new
  # GET /blogs/new.xml
  def new

  # GET /blogs/1/edit
  def edit

  # POST /blogs
  # POST /blogs.xml
  def create

  # PUT /blogs/1
  # PUT /blogs/1.xml
  def update

  # DELETE /blogs/1
  # DELETE /blogs/1.xml
  def destroy
&lt;/pre&gt;
&lt;p&gt;
However this does not tell the whole story, for example these routes have names and these names can be used in your code to add references to the URLs.
&lt;/p&gt;
&lt;p&gt;Another way to look at the roots available is to get Rails to list them. One way of doing this is to execute the &lt;span style="white-space: pre;font-family:monospace;"&gt;rake routes&lt;/span&gt; command:
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
$ rake routes

                    blogs GET    /blogs                       {:controller=&amp;gt;"blogs", :action=&amp;gt;"index"}
          formatted_blogs GET    /blogs.:format               {:controller=&amp;gt;"blogs", :action=&amp;gt;"index"}
                          POST   /blogs                       {:controller=&amp;gt;"blogs", :action=&amp;gt;"create"}
                          POST   /blogs.:format               {:controller=&amp;gt;"blogs", :action=&amp;gt;"create"}
                 new_blog GET    /blogs/new                   {:controller=&amp;gt;"blogs", :action=&amp;gt;"new"}
       formatted_new_blog GET    /blogs/new.:format           {:controller=&amp;gt;"blogs", :action=&amp;gt;"new"}
                edit_blog GET    /blogs/:id/edit              {:controller=&amp;gt;"blogs", :action=&amp;gt;"edit"}
      formatted_edit_blog GET    /blogs/:id/edit.:format      {:controller=&amp;gt;"blogs", :action=&amp;gt;"edit"}
                     blog GET    /blogs/:id                   {:controller=&amp;gt;"blogs", :action=&amp;gt;"show"}
           formatted_blog GET    /blogs/:id.:format           {:controller=&amp;gt;"blogs", :action=&amp;gt;"show"}
                          PUT    /blogs/:id                   {:controller=&amp;gt;"blogs", :action=&amp;gt;"update"}
                          PUT    /blogs/:id.:format           {:controller=&amp;gt;"blogs", :action=&amp;gt;"update"}
                          DELETE /blogs/:id                   {:controller=&amp;gt;"blogs", :action=&amp;gt;"destroy"}
                          DELETE /blogs/:id.:format           {:controller=&amp;gt;"blogs", :action=&amp;gt;"destroy"}
&lt;/pre&gt;
&lt;p&gt;
The format is probably screwed as you look at this but hopefully it's still easy to work out what is going on. This lists the VERB/URL mapping to Controller/action, in this case the routes are only shown for the "blogs" resource, the actual listing is much longer and contains all resources as well as the default routing behaviour. The list is fairly straightforward, it shows the name of the route (if there is one), the HTTP verb, the URL and the controller/action these map to. For example the 'blog' named route says that sending a URL of the form blog/[:id] (e.g. /blogs/1) with the HTTP GET verb results in a call to the blogs controller's show method. In this case the value '1' at the end of the URL will be available as the :id value in the params collection. Notice that not all routes are /controller/action style, but that some simply rely on /controller and the HTTP verb to work out the method to call.
&lt;/p&gt;
&lt;p&gt;
The names of the routes are very useful. For example in the above there are routes named 'blogs', 'blog' and 'new_blog' amongst others. These names can be used to display a URL for that route. As an example in views/blogs/index.html.erb there is a line like this:
&lt;/p&gt;
&lt;pre&gt;
&amp;lt;%= link_to 'New blog', new_blog_path %&amp;gt;
&lt;/pre&gt;
&lt;p&gt;
that says to use the path generated from the new_blog route to get the URL to display.
&lt;/p&gt;
&lt;p&gt;
This is all well and good, and nice and easy to use and if you simply want to use the Rails conventions then you are good. However there are going to be occasions when simply using the defaults does not work. Luckily, for those cases the routing infrastructure is extensible. In the case of this blog I wanted to do two things, I wanted to support multiple blog authors, and I wanted blog IDs to be friendlier. In fact both these things are related, although I've only tackled the first issue at the moment, but the second issue is resolvable using a similar mechanism.  
&lt;/p&gt;
&lt;p&gt;
These issues are to do with the way that Rails identifies resources. It does this via the 'id' primary key. So to get to a blog you would send a GET to http://localhost/blogs/1 where blogs is the name of the controller and 1 is the id of the blog. This isn't ideal for a user. The id is an internal representation that the database uses to identify the blog. An end user doesn't want to say 'go to blog 1', they want to say "kevin's blog" or "harry's blog". To support that blogs should have 'nicknames' and these nicknames then get used to identify the blog, meaning that the url becomes http://localhost/blogs/kevin. Similarly with blog entries, the URL to the entry should include the nickname of the blog and maybe the title of the entry. So something like http://localhost/blog/kevin/my-title rather than http://localhost/blog_entry/1/1, where 'blog-entry' is the name of the controller, the first '1' is the id of the blog and the second '1' is the id of the entry. Fixing this requires several steps some of which I'll cover here. At this point I've not fully converted the code to produce URLs like the above but I'm a large step towards it. That step means not relying on the default routes drawn for REST based controllers and rewriting some of the usage of named routes in the controller and views. 
&lt;/p&gt;
&lt;p&gt;
The first thing I wanted to prevent was the user having to use the 'blog_entry' name for the controller. This is an internal representation and, as a user, I don't like the name. I wanted something shorter, so I've chosen 'blog' as the alias for the controller, you can guarantee that at some point in the future I'll have come up with something else! I also want to use a 'nickname' as an identifier to show whose blog entries we were looking at. This meant I wanted a URL something like http://localhost/blog/kevin to retrieve all blog entries for "kevin". I did this by modifying routes.rb.
&lt;/p&gt;
&lt;p&gt;
In routes.rb I took out the entry for &lt;span style="white-space: pre;font-family:monospace;"&gt;map.resources blog_entries&lt;/span&gt; and added explicit entries for routing. The entries look like this: 
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
  map.blog_entries 'blog/:nickname',
            :controller =&amp;gt; "blog_entries",
            :action =&amp;gt; "index",
            :conditions =&amp;gt; {:method =&amp;gt; :get}

  map.connect 'blog/:nickname',
            :controller =&amp;gt; "blog_entries",
            :action =&amp;gt; "create",
            :conditions =&amp;gt; {:method =&amp;gt; :post}

  map.new_blog_entry 'blog/:nickname/new',
        :controller =&amp;gt; "blog_entries",
        :action =&amp;gt; "new",
        :conditions =&amp;gt; {:method =&amp;gt; :get}

&lt;/pre&gt;
&lt;p&gt;
There are many more entries and there are also also entries for formatted output (basically, I did a rake routes, copied and pasted the code and edited it). The above entries show a number of things: there are two named routes (blog_entries and new_blog_entry), and one unnamed route (the call to map.connect). As an aside notice the the named routes are named with a call to map.some_function. This function does not exist and shows the power of Ruby as a language. Internally the map class will override the method_missing method to add this named route. The routes specify the HTTP verb, the controller to call and the action to use on that controller. Notice that all the routes all specify an extra paramter, :nickname. This will be part of the URL and be passed into code in the params collection in much the same way that :id is passed. Once these routes have been defined you can then use them in code.
&lt;/p&gt;
&lt;p&gt;
The nickname is associated with an individual blog and through that with the entries in that blog. This means that to use the nickname we always need to load the blog associated with it. In the BlogEntriesController class I added a "before_filter" entry. before_filters are code that gets executed before the action. The before_filter looks like this:
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
  before_filter :get_associated_blog

  protected
  def get_associated_blog
    if params[:nickname]
      @blog = Blog.find_by_nickname(params[:nickname])
    else
      @blog = nil
    end
  end
&lt;/pre&gt;
&lt;p&gt;
This finds the associated blog (if it can) and stores it as a member variable of the class. The action is then called, and the action can decide what to do if the blog hasn't been found which will typically be to redirect somewhere. 
&lt;/p&gt;
Modifying routing - recreate mapped routes; unnamed and named; use link_to with params to generate url!
Needed to add another column: ruby script/generate migration add_usershortname_to_user user_id:string
then migrate: rake db:migrate

&lt;pre class="ruby" name="code"&gt;
  def show
    if @blog
      # work here
    else
      redirect_to(:controller =&amp;gt; "blogs")
    end
  end
&lt;/pre&gt;
&lt;p&gt;
This is nice and easy. However you can also use the nickname to build URLs. For example when we create a new blog entry we want to re-direct back to the blog for this nickname. The code for that looks something like:
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
  def create
    
    if @blog       
        @blog_entry = BlogEntry.new(params[:blog_entry])

          if @blog_entry.save
            flash[:notice] = 'BlogEntry was successfully created.'
            format.html { redirect_to(:nickname =&amp;gt; @blog.nickname) }
&lt;/pre&gt;
&lt;p&gt;
Notice that the redirect_to uses the nickname. This ensures that we redirect back to http://localhost/blog/kevin rather than http://localhost/blog.
&lt;/p&gt;
&lt;p&gt;
Another place the nicknames are used are in the views. If we use the standard Rails mapping for routes then we can use the helper functions directly, something like:
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
&amp;lt;%= link_to 'Edit', edit_blog_path(@blog) %&amp;gt; |
&amp;lt;%= link_to 'Back', blogs_path %&amp;gt;
&lt;/pre&gt;
&lt;p&gt;
Where we use the default 'blogs' routing to build URLs for an edit entry and to get to the blogs controller's index page. Now that we've amended the blog_entry routes though we also need to track down and edit the uses of link_to (and url_for and any other use of these paths) in the view files. The primary change is to add the :nickname value to all the links. This is why we made @blog an instance variable in the BlogEntriesController class, so that it would be available in the views. The views will look something like: 
&lt;/p&gt;
&lt;pre class="ruby" name="code"&gt;
&amp;lt;%= link_to 'Show', blog_entry_path(:nickname =&amp;gt; blog_entry.blog.nickname, :id =&amp;gt; blog_entry.id) %&amp;gt;
&amp;lt;%= link_to 'Edit', edit_blog_entry_path(:nickname =&amp;gt; blog_entry.blog.nickname, :id =&amp;gt; blog_entry.id) %&amp;gt;
&amp;lt;%= link_to 'Delete', blog_entry_path(:nickname =&amp;gt; blog_entry.blog.nickname, :id =&amp;gt; blog_entry.id), :confirm =&amp;gt; 'Are you sure?', :method =&amp;gt; :delete  %&amp;gt;
&amp;lt;%= link_to 'New Entry', new_blog_entry_path(:nickname =&amp;gt; @blog.nickname) %&amp;gt;
&lt;/pre&gt;
&lt;p&gt;
Notice that for each of these routes we set the :nickname and the :id values. In fact this was the trickiest part of the entire procedure, figuring out what parameters I needed to pass to the link_to methods. For example there are times when I have to explicitly set :id to an empty string and others where the :id isn't needed at all.
&lt;/p&gt;
&lt;p&gt;
There are some other changes I had to make along the way, notably:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added foreign key constraints to blog table.&lt;/li&gt;
&lt;li&gt;Change admin interface to add name&lt;/li&gt;
&lt;li&gt;Change/add a  create blog UI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Now that's done I intend to go back and fix up the 'blogs' routing so that it also supports nicknames.
&lt;/p&gt;</content><author><name>kevin-jones</name></author></entry><entry><id>55345</id><published>2008-12-02T11:39:16.0-05:00</published><updated>2008-12-02T11:39:16.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Running the latest version of Rails</title><content type="html">&lt;p&gt;By this I mean running the latest Gem version not Edge. In config/environment.rb is a line that says something like&lt;/p&gt;
&lt;pre&gt;
RAILS_GEM_VERSION = '2.1.0' unless defined? RAILS_GEM_VERSION
&lt;/pre&gt;
&lt;p&gt;You can either set this to a specific version or if you want to run off the latest installed (Gem) version then simply comment out the line&lt;/p&gt;

&lt;div class="posttagsblock"&gt;&lt;a rel="tag" href="http://technorati.com/tag/Rails"&gt;Rails&lt;/a&gt;&lt;/div&gt;</content><author><name>kevin-jones</name></author></entry><entry><id>55669</id><published>2008-12-12T05:51:54.0-05:00</published><updated>2008-12-12T05:51:54.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Ruby 1.9 and ActiveRecord</title><content type="html">&lt;p&gt;
I'm trying to use ActiveRecord outside of Rails and with Ruby 1.9. I kept getting an error
&lt;/p&gt;
&lt;pre&gt;
/opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/active_record/base.rb:394:in `&lt;class:Base&gt;': undefined method `cattr_accessor' for ActiveRecord::Base:Class (NoMethodError)
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/active_record/base.rb:391:in `&lt;module:ActiveRecord&gt;'
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/active_record/base.rb:4:in `&lt;top required="required"&gt;'
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/active_record.rb:34:in `require'
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/active_record.rb:34:in `&lt;top required="required"&gt;'
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/activerecord.rb:1:in `require'
	from /opt/local/lib/ruby1.9/gems/1.9.1/gems/activerecord-2.2.2/lib/activerecord.rb:1:in `&lt;top required="required"&gt;'
	from SimpleTest.rb:2:in `require'
	from SimpleTest.rb:2:in `&lt;main&gt;'
&lt;/main&gt;&lt;/top&gt;&lt;/top&gt;&lt;/top&gt;&lt;/module:ActiveRecord&gt;&lt;/class:Base&gt;&lt;/pre&gt;
&lt;p&gt;
so and undefined method cattr_accessor in ActiveRecord::Base.
&lt;/p&gt;
&lt;p&gt;
Trying the same code in 1.8 worked fine. After much searching I discovered that ActiveSupport had to be installed. This looked like it was installed when I installed ActiveRecord, but it possibly wasn't a complete install. 
&lt;/p&gt;
&lt;p&gt;
so after a 
&lt;/p&gt;
&lt;pre&gt;
sudo gem install ActiveSupprt
&lt;/pre&gt;
&lt;p&gt;
I'm good to go
&lt;/p&gt;
&lt;div class="posttagsblock"&gt;&lt;a rel="tag" href="http://technorati.com/tag/Ruby"&gt;Ruby&lt;/a&gt;&lt;/div&gt;</content><author><name>kevin-jones</name></author></entry></feed>